/*
 * Copyright 2026, Salesforce, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { execCmd, TestSession } from '@salesforce/cli-plugins-testkit';
import { Lifecycle, Messages, SandboxEvents, SandboxProcessObject, StatusEvent } from '@salesforce/core';
import { expect, assert, config } from 'chai';

config.truncateThreshold = 0;

Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);

describe('Sandbox Orgs', () => {
  let session: TestSession;
  let hubOrgUsername: string;

  before(async () => {
    session = await TestSession.create({
      project: { name: 'sandboxCreate' },
      devhubAuthStrategy: 'AUTO',
    });
    assert(session.hubOrg.username);
    hubOrgUsername = session.hubOrg.username;
  });

  it('will create a sandbox, verify it can be opened, and then attempt to delete it', () => {
    let result: SandboxProcessObject | undefined;
    try {
      Lifecycle.getInstance().on(SandboxEvents.EVENT_ASYNC_RESULT, async (results: StatusEvent) =>
        // eslint-disable-next-line no-console
        Promise.resolve(console.log('sandbox copy progress', results.sandboxProcessObj.CopyProgress))
      );
      let rawResult = execCmd(
        `env:create:sandbox -a mySandbox -s -l Developer -o ${hubOrgUsername} --no-prompt --json --async`,
        { timeout: 3_600_000, ensureExitCode: 68 }
      );
      result = rawResult.jsonOutput?.result as SandboxProcessObject;
      // autogenerated sandbox names start with 'sbx'
      expect(result).to.be.ok;
      expect(result.SandboxName.startsWith('sbx'), 'env:create:sandbox').to.be.true;
      rawResult = execCmd<SandboxProcessObject>(
        `env:resume:sandbox --name ${result.SandboxName} -o ${hubOrgUsername} -w 60 --json`,
        { timeout: 3_600_000 }
      );
      result = rawResult.jsonOutput?.result as SandboxProcessObject;
      expect(result).to.be.ok;
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      expect(false, 'catch verification').to.be.true(JSON.stringify(e));
    }

    assert(result);
    const sandboxUsername = `${hubOrgUsername}.${result.SandboxName}`;
    // even if a DNS issue occurred, the sandbox should still be present and available.
    const openResult = execCmd<{ url: string }>('org:open -o mySandbox --url-only --json', {
      ensureExitCode: 0,
    }).jsonOutput?.result;
    assert(openResult, 'env:open');
    expect(openResult.url, 'env:open').to.ok;

    const deleteResult = execCmd<{ username: string }>('env:delete:sandbox --target-org mySandbox --no-prompt --json', {
      ensureExitCode: 0,
    }).jsonOutput?.result;
    assert(deleteResult, 'env:delete:sandbox');
    expect(deleteResult.username, 'env:delete:sandbox').to.equal(sandboxUsername);
  });

  after(async () => {
    try {
      await session?.clean();
    } catch (e) {
      // do nothing
    }
  });
});
